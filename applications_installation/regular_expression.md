# 正则表达式
>正则表达式是一种用来匹配字符串的强有力武器。其设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，即可认为它“匹配”了，否则，该字符串即为不合法。

##  描述字符
``‘\d’ `` 匹配``一个``数字，``‘\w’``匹配一个字母或数字：

* ``‘\d\d\d’``可以匹配``‘007’``,无法匹配``‘00A’``
* ``‘\w\w\d’``可以匹配``py3``,``‘115’``
* ``.``可以匹配任意``一个``字符，如：``‘py.’``可以匹配 ``‘pyc’`` ``‘pyo’`` ``‘py!’`` ``‘py2’`` 
* 变长字符的匹配：
	* ``*``表示任意个字符（包括0个），用``+``表示至少一个字符，用``?``表示0个或1个字符，用``{n}``表示n个字符，用``{n,m}``表示``n-m``个字符
	* 更复杂一点，如：``\d{3}\s+\d{3,8}``
		* ``\d{3}`` 表示匹配3个数字
		* ``\s``表示可以匹配一个空格（包括tab键等空白符），所以``\s+``表示至少匹配一个空格，例如``''``  ``'	'``
		*\d{3-8}表示3-8个数字，例如``'123455'``
	所以，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码
## 进阶
> 做更精确地匹配，可以用``[]``表示范围，比如：

* ``[0-9a-zA-Z\_]``匹配一个数字，字母或者下划线
* ``[0-9a-zA-Z\_]+``匹配至少由一个数字，字母或者下划线组成的字符串，例如：``aff_121`` ``12_hjs_ad`` ``a2w13s1``
* ``[a-zA-Z\_][0-9a-zA-Z\_]*``匹配由字母或下划线开头，后接任意个由数字，字母或下划线组成的字符串（可以接0个）
* ``[a-zA-Z\_][0-9a-zA-Z\_]{0-19}``更精确地限制了变量的长度是1-20个字符（前面一个字符，后面最多19个字符）
* ``A|B``匹配A或B,所以``(P|p)ython`` 匹配 ``'Pyhon'``  ``'python'``
* ``^``表示行的开头，``^\d``表示必须以数字开头  ``$``表示行的结束，``\d$``表示必须以数字结束
注意：``^`` ``$``表示的是整行匹配，一旦不符合规则，整行均不匹配

## re模块
* ``re.match``: ``re.match(r'^\d{3}\-\d{3-8}$','010-3465798')``
如果不匹配，则无输出None，否则输出一个正则匹配对象
* ``re.split``:``re.split(r'[\s\,]+','a,	,b,,,,c')``
如果匹配，输出一个字符串列表
用户若输入一组标签，记得用正则表达式把不规范的输入转化成正确的数组
## 分组匹配
``^(\d{3})-(\d{3-8})$``分别定义了两个组，可以直接从匹配的字符串中提取区号和本地号码
```python
>>> m = re.match(r'^(\d{3})-(\d{3-8})$','010-3455678')
>>> m
<_sre.SRE_Match object; span=(0,11), match='010-3455678'>
>>> m.group(0)
'010-3455678'
>>> m.group(1)
'010'
>>> m.group(2)
'3455678'

```
如果正则表达式定义了组，就可以在``match``对象上用``group()``方法提取出子串来。
注意：``group(0)``永远是原始字符串 ``group(1)``， ``group(2)``......表示第1个，第2个子串......
``groups()``表示分组后的各个元素组成的元组(tuple)即：
```python
>>> m. groups()
(group(1),group(2),...)
```

```python
>>> t = '19:05:30'
>>> m =  re.match(r'^([0-1][0-9]|[2][0-3])\:([0-5][0-9])\:([0-5][0-9])$',t)
>>> m
<sre.SRE_Match object; span=(0, 8), match='19:05:30'>
>>> m.groups()
('19', '05', '30')
>>> m.group(0)
 '19:05:30'
 >>> m.group(1)
 '19'
 >>>  m.group(2)
  '05'
  >>> m.group(3)
  '30'
```
## 贪婪匹配
> 需要指出的是，正则匹配默认是贪婪匹配，即匹配尽可能多的字符。

```python
>>> re.match(r'^(\d+)(0*)$','102300').groups()
('102300','')
# 利用?就可以实现非贪婪匹配了
>>> re.match(r'^(\d+?)(0*)$','102300').groups()
('1023','00')
```
## 编译
> 在Python中使用正则表达式时，re模块内部做两件事：
* 1. 编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
* 2. 用编译后的正则表达式去匹配字符串。
如果一个正则表达式要重复使用几千次，可以预编译该正则表达式，然后利用预编译的表达式直接匹配：
```python
>>> import re
>>> re_telephone  =  re.compile(r'^(\d{3})-(\d{3-8})$')
>>> re_telephone.match('010-34567845').groups()
('010','34567845')
```

